% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cutYears.R
\name{cutYears}
\alias{cutYears}
\title{Transform a vector of year values into an ordered factor of year groups.}
\usage{
cutYears(x, breaks, levelsBoundedByData = TRUE, shortLabels = FALSE)
}
\arguments{
\item{x}{Vector of four-digit integers, or of four-character strings
that can be converted to integers, e.g., "1900".}

\item{breaks}{Numeric vector of cutpoints}

\item{levelsBoundedByData}{Logical. Ensures that the lowest and highest
levels of the returned factor will contain some data. Also ensures that
the label for the highest factor level reports the maximum year in
\code{x}, rather than a higher year.}

\item{shortLabels}{Logical. If \code{FALSE}, the second year in each
label will always have four digits: for example, "1975-1999". If
\code{TRUE} (the default), the second year in each label will typically
have two digits: for example, "1975-99". But even if \code{shortLabels}
is \code{TRUE}, the second year in a label will have four digits if it
isn't in the same century as the first year. For example,
\code{cutYears()} will always produce a label like "1975-2001" instead of
"1975-01".}
}
\description{
This function is a wrapper around \linkInt{cut}. Given a vector of
strings or integers that represent years, and a vector of breakpoints, it
returns a factor in which each level represents a group of years. Unlike
\code{cut()}, it returns pretty labels for the levels: "1975-79" instead
of "[1975,1980)", and so on. Also unlike \code{cut()}, it ensures that
all of the data are accounted for in the levels of the factor that it
creates: data will never be dropped from a factor that \code{cutYears()}
returns.
}
\details{
By default, \code{cutYears()} differs from \code{cut()} in the following
ways:
\itemize{
\item Accepts only \code{x} vectors in which every value has four characters or
four digits.
\item Returns a factor that has better labels for groups of years: for
example, "1975-80" rather than "[1975,1980)".
\item Returns factor levels that encompass all values of \code{x}. Consequently,
\code{cutYears()} will never convert year values to \code{NA}, as \code{cut()} will
often do.
\item Returns an ordered factor by default.
\item By default, \code{cutYears()} drops levels that are outside the bounds
of \code{x}. For example, if \code{x} ranges from 1975 to 1985, the factor
returned by \code{cut()} may have an infinite number of levels, including,
say, "(1900-1905]". (The exact levels returns by \code{cut()} depend on the
arguments passed to it, especially the \code{breaks} argument.) But in a
case like this, the lowest factor level returned by \code{cutYears()} will
include 1975, and the highest factor level returned by \code{cutYears()}
will contain 1985.
}
}
\examples{
years <- rep(1975:1993, each = 3)
fac1a <- cut(     years, breaks = seq(1975, 1993, by = 3))
fac1b <- cutYears(years, breaks = seq(1975, 1993, by = 3))
fac1c <- cutYears(years, breaks = seq(1975, 1993, by = 3), shortLabels = FALSE)
 
table(fac1a)
table(fac1b)
table(fac1c)

fac2a <- cut(     years, breaks = seq(1975, 1990, by = 3))
fac2b <- cutYears(years, breaks = seq(1975, 1990, by = 3))
table(fac2a)
table(fac2b)

fac3a <- cut(     years, breaks = seq(1955, 1990, by = 3))
fac3b <- cutYears(years, breaks = seq(1955, 1990, by = 3))
table(fac3a)
table(fac3b)
}
\seealso{
\linkInt{cut}, \code{\link[Hmisc:cut2]{Hmisc::cut2()}}
}
