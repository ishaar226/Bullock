% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stackUtils.R
\name{stackUtilities}
\alias{stackUtilities}
\alias{newStack}
\alias{push}
\alias{pop}
\alias{shift}
\alias{unshift}
\title{Perl-like stack utilities for R.}
\usage{
newStack(x = NULL)

push(stack, x)

pop(stack)

shift(stack, x)

unshift(stack)
}
\arguments{
\item{x}{Vector.}

\item{stack}{Stack object.}
}
\value{
For \code{new_stack()}, a stack object. For \code{pop()}, the last element
of the stack object (which will also be removed from the stack object). For
\code{unshift()}, the first element of the stack object (which will also 
be removed from the stack object).
}
\description{
\code{newStack()} constructs a "stack"---a vector---of data. You can "push"  
new data onto the end of the vector with \code{push()} or "pop" data off 
the end of it, one at a time, with \code{pop()}. You can also \code{shift()}
data onto beginning of the vector or \code{unshift()} values from the 
beginning of the vector---that is, remove them from the vector---one at a 
time.
}
\details{
An important and unusual feature of \code{push(), pop(), shift(),} and 
\code{unshift()} is that they modify \code{stack} objects "in place"---that 
is, even when no explicit assignment is done. For example, \code{pop(x)} 
will return the last value of \code{x}, but it will also remove the last 
value from the \code{x} object. The examples illustrate this point.

Adapted from Jeffrey A. Ryan's code at \url{http://www.lemnica.com/esotericR/Introducing-Closures/}.
}
\examples{
myStack <- newStack(1:3)
push(myStack, 4)
myStack$data

pop(myStack)      # remove last element
unshift(myStack)  # remove first element
myStack$data

shift(myStack, 'hello')
myStack$data


}
\author{
Jeffrey A. Ryan
John G. Bullock
}
